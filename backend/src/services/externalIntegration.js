const axios = require('axios');

// Mock external integration service for demo purposes
// In a real implementation, this would integrate with:
// - FixMyStreet API for municipal reporting
// - Smart City portals
// - Traffic management systems
// - Emergency services APIs

/**
 * Sync ticket with FixMyStreet API
 * @param {Object} ticket - Ticket object
 * @param {string} system - External system name
 * @returns {Promise<Object>} - Sync result
 */
const syncWithExternalSystem = async (ticket, system = 'fixmystreet') => {
  try {
    console.log(`Syncing ticket ${ticket.ticketId} with ${system}`);
    
    switch (system) {
      case 'fixmystreet':
        return await syncWithFixMyStreet(ticket);
      case 'smart_city':
        return await syncWithSmartCity(ticket);
      case 'municipal_corp':
        return await syncWithMunicipalCorp(ticket);
      case 'traffic_police':
        return await syncWithTrafficPolice(ticket);
      default:
        throw new Error(`Unknown external system: ${system}`);
    }
  } catch (error) {
    console.error(`External sync failed for ${system}:`, error);
    throw error;
  }
};

/**
 * Sync with FixMyStreet API
 * @param {Object} ticket - Ticket object
 * @returns {Promise<Object>} - Sync result
 */
const syncWithFixMyStreet = async (ticket) => {
  try {
    const fixMyStreetPayload = {
      title: `AI-Detected ${ticket.issueType}: ${ticket.description}`,
      detail: `Automated report generated by AI hazard detection system.\n\n` +
              `Hazard Type: ${ticket.issueType}\n` +
              `Severity: ${ticket.severity}\n` +
              `Location: ${ticket.location.address || 'GPS coordinates provided'}\n` +
              `Confidence: ${Math.round(ticket.metadata?.confidence * 100 || 0)}%\n` +
              `Detected: ${ticket.submittedAt.toISOString()}\n\n` +
              `This report was automatically generated. Please verify the issue and take appropriate action.`,
      name: 'AI Hazard Detection System',
      email: 'ai-system@hazarddetection.com',
      category: mapHazardTypeToFixMyStreetCategory(ticket.issueType),
      lat: ticket.location.coordinates[1],
      lng: ticket.location.coordinates[0],
      service: 'AI_Hazard_Detection',
      external_id: ticket.ticketId,
      extra: {
        hazard_id: ticket.hazardId,
        confidence: ticket.metadata?.confidence,
        detection_method: 'ai_vision_accelerometer_audio',
        vehicle_context: ticket.evidence?.sensorData?.gps,
        images: ticket.evidence?.images?.map(img => img.url) || []
      }
    };

    // Mock API call to FixMyStreet
    const response = await mockApiCall('POST', 'https://api.fixmystreet.com/reports', fixMyStreetPayload);
    
    // Update ticket with external system info
    await ticket.syncWithExternal('fixmystreet', response.report_id, response.status);
    
    return {
      system: 'fixmystreet',
      externalId: response.report_id,
      status: response.status,
      url: response.url,
      syncedAt: new Date()
    };
  } catch (error) {
    console.error('FixMyStreet sync failed:', error);
    throw new Error('Failed to sync with FixMyStreet');
  }
};

/**
 * Sync with Smart City Portal
 * @param {Object} ticket - Ticket object
 * @returns {Promise<Object>} - Sync result
 */
const syncWithSmartCity = async (ticket) => {
  try {
    const smartCityPayload = {
      incidentId: ticket.ticketId,
      incidentType: 'ROAD_HAZARD',
      subType: ticket.issueType.toUpperCase(),
      severity: ticket.severity.toUpperCase(),
      location: {
        latitude: ticket.location.coordinates[1],
        longitude: ticket.location.coordinates[0],
        address: ticket.location.address,
        ward: ticket.location.ward || 'Unknown',
        zone: ticket.location.zone || 'Unknown'
      },
      description: ticket.description,
      reportedBy: 'AI_SYSTEM',
      reportedAt: ticket.submittedAt.toISOString(),
      priority: mapSeverityToPriority(ticket.severity),
      estimatedResolutionTime: calculateEstimatedResolutionTime(ticket),
      attachments: ticket.evidence?.images?.map(img => ({
        url: img.url,
        type: 'image',
        caption: img.caption
      })) || [],
      metadata: {
        confidence: ticket.metadata?.confidence,
        detectionMethod: 'AI_VISION_ACCELEROMETER_AUDIO',
        source: 'MOBILE_APP'
      }
    };

    // Mock API call to Smart City Portal
    const response = await mockApiCall('POST', 'https://api.smartcity.gov.in/incidents', smartCityPayload);
    
    await ticket.syncWithExternal('smart_city', response.incidentId, response.status);
    
    return {
      system: 'smart_city',
      externalId: response.incidentId,
      status: response.status,
      trackingUrl: response.trackingUrl,
      syncedAt: new Date()
    };
  } catch (error) {
    console.error('Smart City sync failed:', error);
    throw new Error('Failed to sync with Smart City Portal');
  }
};

/**
 * Sync with Municipal Corporation
 * @param {Object} ticket - Ticket object
 * @returns {Promise<Object>} - Sync result
 */
const syncWithMunicipalCorp = async (ticket) => {
  try {
    const municipalPayload = {
      complaintNumber: ticket.ticketId,
      complaintType: 'ROAD_MAINTENANCE',
      subCategory: mapHazardTypeToMunicipalCategory(ticket.issueType),
      description: ticket.description,
      location: {
        coordinates: {
          latitude: ticket.location.coordinates[1],
          longitude: ticket.location.coordinates[0]
        },
        address: ticket.location.address,
        landmark: ticket.location.landmark,
        pincode: ticket.location.pincode
      },
      complainant: {
        name: 'AI Hazard Detection System',
        contact: 'ai-system@hazarddetection.com',
        type: 'SYSTEM'
      },
      priority: mapSeverityToMunicipalPriority(ticket.severity),
      expectedResolutionDate: calculateExpectedResolutionDate(ticket),
      attachments: ticket.evidence?.images || [],
      additionalInfo: {
        detectionConfidence: ticket.metadata?.confidence,
        vehicleSpeed: ticket.evidence?.sensorData?.gps?.speed,
        impactIntensity: ticket.evidence?.sensorData?.accelerometer?.magnitude
      }
    };

    // Mock API call to Municipal Corporation
    const response = await mockApiCall('POST', 'https://api.municipal.gov.in/complaints', municipalPayload);
    
    await ticket.syncWithExternal('municipal_corp', response.complaintId, response.status);
    
    return {
      system: 'municipal_corp',
      externalId: response.complaintId,
      status: response.status,
      referenceNumber: response.referenceNumber,
      syncedAt: new Date()
    };
  } catch (error) {
    console.error('Municipal Corporation sync failed:', error);
    throw new Error('Failed to sync with Municipal Corporation');
  }
};

/**
 * Sync with Traffic Police
 * @param {Object} ticket - Ticket object
 * @returns {Promise<Object>} - Sync result
 */
const syncWithTrafficPolice = async (ticket) => {
  try {
    // Only sync high/critical severity hazards with traffic police
    if (!['high', 'critical'].includes(ticket.severity)) {
      return {
        system: 'traffic_police',
        status: 'not_required',
        reason: 'Severity below threshold for traffic police notification'
      };
    }

    const trafficPolicePayload = {
      alertId: ticket.ticketId,
      alertType: 'ROAD_HAZARD',
      hazardType: ticket.issueType.toUpperCase(),
      severity: ticket.severity.toUpperCase(),
      location: {
        latitude: ticket.location.coordinates[1],
        longitude: ticket.location.coordinates[0],
        address: ticket.location.address,
        roadName: ticket.location.roadName || 'Unknown Road',
        junction: ticket.location.junction || 'Unknown Junction'
      },
      description: ticket.description,
      reportedBy: 'AI_SYSTEM',
      reportedAt: ticket.submittedAt.toISOString(),
      urgency: ticket.severity === 'critical' ? 'IMMEDIATE' : 'HIGH',
      estimatedTrafficImpact: calculateTrafficImpact(ticket),
      recommendedActions: generateRecommendedActions(ticket),
      contactInfo: {
        system: 'AI Hazard Detection',
        email: 'ai-system@hazarddetection.com',
        phone: '+1-555-AI-ALERT'
      }
    };

    // Mock API call to Traffic Police
    const response = await mockApiCall('POST', 'https://api.trafficpolice.gov.in/alerts', trafficPolicePayload);
    
    await ticket.syncWithExternal('traffic_police', response.alertId, response.status);
    
    return {
      system: 'traffic_police',
      externalId: response.alertId,
      status: response.status,
      dispatchNumber: response.dispatchNumber,
      syncedAt: new Date()
    };
  } catch (error) {
    console.error('Traffic Police sync failed:', error);
    throw new Error('Failed to sync with Traffic Police');
  }
};

/**
 * Mock API call for demo purposes
 * @param {string} method - HTTP method
 * @param {string} url - API URL
 * @param {Object} data - Request data
 * @returns {Promise<Object>} - Mock response
 */
const mockApiCall = async (method, url, data) => {
  console.log(`Mock API call: ${method} ${url}`);
  console.log('Request data:', JSON.stringify(data, null, 2));
  
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
  
  // Mock successful response
  const mockResponse = {
    report_id: `FMS_${Date.now()}`,
    incidentId: `SC_${Date.now()}`,
    complaintId: `MC_${Date.now()}`,
    alertId: `TP_${Date.now()}`,
    status: 'submitted',
    url: `https://fixmystreet.com/report/${Date.now()}`,
    trackingUrl: `https://smartcity.gov.in/track/${Date.now()}`,
    referenceNumber: `REF_${Date.now()}`,
    dispatchNumber: `DISP_${Date.now()}`
  };
  
  console.log('Mock response:', mockResponse);
  return mockResponse;
};

// Helper functions
function mapHazardTypeToFixMyStreetCategory(hazardType) {
  const mapping = {
    'pothole': 'Pothole',
    'debris': 'Street cleaning',
    'speed_breaker': 'Road maintenance',
    'stalled_vehicle': 'Traffic management',
    'construction': 'Road works',
    'flooding': 'Drainage',
    'other': 'Other'
  };
  return mapping[hazardType] || 'Other';
}

function mapHazardTypeToMunicipalCategory(hazardType) {
  const mapping = {
    'pothole': 'ROAD_REPAIR',
    'debris': 'STREET_CLEANING',
    'speed_breaker': 'ROAD_MAINTENANCE',
    'stalled_vehicle': 'TRAFFIC_MANAGEMENT',
    'construction': 'ROAD_WORKS',
    'flooding': 'DRAINAGE',
    'other': 'GENERAL'
  };
  return mapping[hazardType] || 'GENERAL';
}

function mapSeverityToPriority(severity) {
  const mapping = {
    'low': 'LOW',
    'medium': 'MEDIUM',
    'high': 'HIGH',
    'critical': 'URGENT'
  };
  return mapping[severity] || 'MEDIUM';
}

function mapSeverityToMunicipalPriority(severity) {
  const mapping = {
    'low': 3,
    'medium': 2,
    'high': 1,
    'critical': 0
  };
  return mapping[severity] || 2;
}

function calculateEstimatedResolutionTime(ticket) {
  const baseHours = {
    'low': 72,
    'medium': 48,
    'high': 24,
    'critical': 8
  };
  
  const baseTime = baseHours[ticket.severity] || 48;
  const confidenceMultiplier = ticket.metadata?.confidence || 0.5;
  
  return Math.round(baseTime * (2 - confidenceMultiplier));
}

function calculateExpectedResolutionDate(ticket) {
  const hours = calculateEstimatedResolutionTime(ticket);
  const resolutionDate = new Date(ticket.submittedAt.getTime() + hours * 60 * 60 * 1000);
  return resolutionDate.toISOString();
}

function calculateTrafficImpact(ticket) {
  const impactFactors = {
    'low': 'MINIMAL',
    'medium': 'MODERATE',
    'high': 'SIGNIFICANT',
    'critical': 'SEVERE'
  };
  return impactFactors[ticket.severity] || 'MODERATE';
}

function generateRecommendedActions(ticket) {
  const actions = [];
  
  switch (ticket.issueType) {
    case 'pothole':
      actions.push('Deploy road repair crew');
      actions.push('Set up temporary warning signs');
      break;
    case 'stalled_vehicle':
      actions.push('Dispatch towing service');
      actions.push('Redirect traffic if necessary');
      break;
    case 'flooding':
      actions.push('Deploy drainage team');
      actions.push('Set up road closure if severe');
      break;
    case 'construction':
      actions.push('Verify construction permits');
      actions.push('Ensure proper safety measures');
      break;
    default:
      actions.push('Assess situation on-site');
      actions.push('Take appropriate remedial action');
  }
  
  if (ticket.severity === 'critical') {
    actions.unshift('IMMEDIATE RESPONSE REQUIRED');
  }
  
  return actions;
}

module.exports = {
  syncWithExternalSystem,
  syncWithFixMyStreet,
  syncWithSmartCity,
  syncWithMunicipalCorp,
  syncWithTrafficPolice
};
